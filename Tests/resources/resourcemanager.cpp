#include "resourcemanager.h"
#include <cstdlib>
#include <cstdio>
malloc_function __g__malloc { ::malloc };
FILE *__g_resource_handle { nullptr };
void set_malloc_function(malloc_function func) { __g__malloc = func; }
void init_resources() {	if(__g_resource_handle == nullptr) __g_resource_handle = fopen("rc_pack.crp", "rb"); }
void deinit_resources() { if(__g_resource_handle) fclose(__g_resource_handle); __g_resource_handle = nullptr; }
resource load_binery_resource(void *buffer, size_t start, size_t size) {
resource res;
if(__g_resource_handle) {
fseek(__g_resource_handle, start, SEEK_SET);
res.buffer = (unsigned char *)buffer;
res.size = fread(res.buffer, 1, size, __g_resource_handle);
}
return res;
}
resource get_res_freesans_ttf (void* ptr_) { return load_binery_resource(ptr_, 0, 1563256); }
size_t get_res_freesans_ttf_size () { return 1563256; }
resource get_res_venus_dds (void* ptr_) { return load_binery_resource(ptr_, 1563256, 699216); }
size_t get_res_venus_dds_size () { return 699216; }
resource get_res_ganymede_dds (void* ptr_) { return load_binery_resource(ptr_, 2262472, 699216); }
size_t get_res_ganymede_dds_size () { return 699216; }
resource get_res_uranus_dds (void* ptr_) { return load_binery_resource(ptr_, 2961688, 699216); }
size_t get_res_uranus_dds_size () { return 699216; }
resource get_res_enceladus_dds (void* ptr_) { return load_binery_resource(ptr_, 3660904, 699216); }
size_t get_res_enceladus_dds_size () { return 699216; }
resource get_res_sun_dds (void* ptr_) { return load_binery_resource(ptr_, 4360120, 699216); }
size_t get_res_sun_dds_size () { return 699216; }
resource get_res_saturn_dds (void* ptr_) { return load_binery_resource(ptr_, 5059336, 699216); }
size_t get_res_saturn_dds_size () { return 699216; }
resource get_res_neptune_dds (void* ptr_) { return load_binery_resource(ptr_, 5758552, 699216); }
size_t get_res_neptune_dds_size () { return 699216; }
resource get_res_rhea_dds (void* ptr_) { return load_binery_resource(ptr_, 6457768, 699216); }
size_t get_res_rhea_dds_size () { return 699216; }
resource get_res_mercury_dds (void* ptr_) { return load_binery_resource(ptr_, 7156984, 699216); }
size_t get_res_mercury_dds_size () { return 699216; }
resource get_res_titan_dds (void* ptr_) { return load_binery_resource(ptr_, 7856200, 699216); }
size_t get_res_titan_dds_size () { return 699216; }
resource get_res_earth_dds (void* ptr_) { return load_binery_resource(ptr_, 8555416, 699216); }
size_t get_res_earth_dds_size () { return 699216; }
resource get_res_mimas_dds (void* ptr_) { return load_binery_resource(ptr_, 9254632, 699216); }
size_t get_res_mimas_dds_size () { return 699216; }
resource get_res_moon_dds (void* ptr_) { return load_binery_resource(ptr_, 9953848, 699216); }
size_t get_res_moon_dds_size () { return 699216; }
resource get_res_europa_dds (void* ptr_) { return load_binery_resource(ptr_, 10653064, 699216); }
size_t get_res_europa_dds_size () { return 699216; }
resource get_res_dione_dds (void* ptr_) { return load_binery_resource(ptr_, 11352280, 699216); }
size_t get_res_dione_dds_size () { return 699216; }
resource get_res_jupiter_dds (void* ptr_) { return load_binery_resource(ptr_, 12051496, 699216); }
size_t get_res_jupiter_dds_size () { return 699216; }
resource get_res_mars_dds (void* ptr_) { return load_binery_resource(ptr_, 12750712, 699216); }
size_t get_res_mars_dds_size () { return 699216; }
resource get_res_iapetus_dds (void* ptr_) { return load_binery_resource(ptr_, 13449928, 699216); }
size_t get_res_iapetus_dds_size () { return 699216; }
resource get_res_io_dds (void* ptr_) { return load_binery_resource(ptr_, 14149144, 699216); }
size_t get_res_io_dds_size () { return 699216; }
resource get_res_tethys_dds (void* ptr_) { return load_binery_resource(ptr_, 14848360, 699216); }
size_t get_res_tethys_dds_size () { return 699216; }
resource get_res_callisto_dds (void* ptr_) { return load_binery_resource(ptr_, 15547576, 699216); }
size_t get_res_callisto_dds_size () { return 699216; }

const char *get_res_particles_render_frag_glsl () { return "#version 330\n\nuniform sampler2D tsampler[1];\nuniform int tcount;\n\nsmooth in vec2 vTexCoord;\nsmooth in vec4 vColorPart;\n//in vec4 gl_FragCoord;\n\nout vec4 FragColor;\n\nvoid main()\n{\n    vec2 uv = vTexCoord.xy;\n//    uv.y *= -1.0;\n    vec3 vTexColor = texture2D(tsampler[0], uv).xyz;\n    float alpha = 0.0;\n    for(float i = 0.001; i < 1.0; i+=i)\n    {\n        if(vTexColor.r > i && vTexColor.g > i && vTexColor.b > i)\n        {\n            alpha = i;\n        }\n    }\n    if(alpha < 0.05)\n    {\n        discard;\n    }\n    else\n    {\n        alpha -= gl_FragCoord.z * 0.01;\n        FragColor = vec4(vColorPart.xyz, vColorPart.w * alpha);\n    }\n}\n"; }
const char *get_res_skybox_frag_glsl () { return "#version 330\n\nuniform samplerCube tsampler[1];\nsmooth in vec4 UV;\nout vec4 outColour;\n\nvoid main()\n{\n    outColour = texture(tsampler[0], UV);\n}\n"; }
const char *get_res_basic_frag_glsl () { return "#version 330\n\nin vec3 colour;\nout vec4 outColour;\n\nvoid main()\n{\n\n    outColour = vec4(colour, 0.1);\n}\n"; }
const char *get_res_particles_render_geom_glsl () { return "#version 330\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nuniform vec3 vQuad1, vQuad2;\n\nlayout(points) in;\nlayout(triangle_strip) out;\nlayout(max_vertices = 4) out;\n\nin vec3 vColorPass[1];\nin float fLifeTimePass[1];\nin float fSizePass[1];\nin float iTypePass[1];\n\nsmooth out vec2 vTexCoord;\nsmooth out vec4 vColorPart;\n\nvoid main()\n{\n        vec3 vPosOld = gl_in[0].gl_Position.xyz;\n        float fSize = fSizePass[0];\n        mat4 mVP = projectionMatrix* viewMatrix;\n\n//        float fdiv = fSize * (vQuad1+vQuad2).x / 2;\n        float val = fLifeTimePass[0];// / 500.0;\n        vColorPart = vec4(vColorPass[0], 1.0);\n\n        vec3 vPos = vPosOld + ((-vQuad1-vQuad2) * fSize);\n        vTexCoord = vec2(0.0, 0.0);\n        gl_Position = mVP * vec4(vPos, 1.0);\n        EmitVertex();\n\n        vPos = vPosOld + ((-vQuad1+vQuad2) * fSize);\n        vTexCoord = vec2(0.0, 1.0);\n        gl_Position = mVP * vec4(vPos, 1.0);\n        EmitVertex();\n\n        vPos = vPosOld + ((vQuad1-vQuad2) * fSize);\n        vTexCoord = vec2(1.0, 0.0);\n        gl_Position = mVP * vec4(vPos, 1.0);\n        EmitVertex();\n\n        vPos = vPosOld + ((vQuad1+vQuad2) * fSize);\n        vTexCoord = vec2(1.0, 1.0);\n        gl_Position = mVP * vec4(vPos, 1.0);\n        EmitVertex();\n\n        EndPrimitive();\n}\n"; }
const char *get_res_particles_update_frag_glsl () { return "#version 330\n\nout vec4 vColor;\n\nvoid main()\n{\n    vColor = vec4(1.0, 1.0, 1.0, 1.0);\n}\n"; }
const char *get_res_object_frag_glsl () { return "#version 330\n\nuniform sampler2D texture;\nuniform vec3 lightPosition;\nuniform float lightStrength;\nuniform int objectSelected;\n\nin vec2 UV;\nin vec3 Position_worldspace;\nin vec3 Normal_cameraspace;\nin vec3 EyeDirection_cameraspace;\nin vec3 LightDirection_cameraspace;\n\nout vec4 colour;\n\nvoid main()\n{\n\n    vec4 tmpc = texture2D(texture, UV);\n    colour = tmpc;\n//    for(int i = 0; i < tcount; i++)\n//    {\n//        if(i == 0)\n//        {\n//            tmpc+=texture2D(tsampler[0], UV);\n//        }\n//        else if(i == 1)\n//        {\n//            tmpc+=texture2D(tsampler[1], UV);\n//        }\n//        else if(i == 2)\n//        {\n//            tmpc+=texture2D(tsampler[2], UV);\n//        }\n//        else if(i == 3)\n//        {\n//            tmpc+=texture2D(tsampler[3], UV);\n//        }\n//        else if(i == 4)\n//        {\n//            tmpc+=texture2D(tsampler[4], UV);\n//        }\n//    }\n//    if(tcount == 0)\n//    {\n//        tmpc = vec4(UV.x, UV.y, 0.35, 1.0);\n//    }\n\n//    vec3 LightColor = vec3(1,0.92,0.90);\n//    if(objectSelected == 1)\n//    {\n//        LightColor = vec3(0.89,0.42,0.48);\n//    }\n//    float LightPower = length( lightPosition ) * lightStrength;\n\n//    vec3 MaterialDiffuseColor = tmpc.rgb;\n//    vec3 MaterialAmbientColor = vec3(0.82,0.82,0.82) * MaterialDiffuseColor;\n//    vec3 MaterialSpecularColor = vec3(0.25,0.25,0.25);\n\n//    float distance = length( lightPosition - Position_worldspace );\n\n//    vec3 n = normalize( Normal_cameraspace );\n//    vec3 l = normalize( LightDirection_cameraspace );\n//    float cosTheta = clamp( dot( n,l ), 0.1, 1 );\n\n//    vec3 E = normalize(EyeDirection_cameraspace);\n//    vec3 R = reflect(-l,n);\n//    float cosAlpha = clamp(dot( E,R ), 0, 1);\n\n//    colour = MaterialAmbientColor * LightColor +\n//            MaterialDiffuseColor * LightColor  * cosTheta / (distance*distance) +\n//            MaterialSpecularColor * LightColor  * pow(cosAlpha,5) / (distance*distance);\n\n\n}\n"; }
const char *get_res_text_frag_glsl () { return "#version 330\n\nin vec2 texCoord;\nout vec4 outColour;\n\nuniform sampler2D texture;\nuniform vec4 colour;\n\nvoid main() {\n    vec4 textColour = texture2D(texture, texCoord);\n    outColour = vec4(textColour.r, textColour.r,\n                     textColour.r, textColour.r) *\n            colour;\n}\n"; }
const char *get_res_text_vert_glsl () { return "#version 330\n\nuniform mat4 modelMatrix;\nuniform mat4 projectionMatrix;\n\nlayout(location = 0) in vec2 inPosition;\nlayout(location = 1) in vec2 inCoord;\n\nout vec2 texCoord;\n\nvoid main() {\n    gl_Position = projectionMatrix * modelMatrix *\n            vec4(inPosition, 0.0, 1.0);\n    texCoord = inCoord;\n}\n"; }
const char *get_res_basic_vert_glsl () { return "#version 330\n\nlayout(location = 0) in vec3 inPosition;\nlayout(location = 1) in vec3 inColour;\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 modelMatrix;\n\nout vec3 colour;\n\nvoid main()\n{\n    colour = inColour;\n    mat4 MVP = (projectionMatrix * viewMatrix * modelMatrix);\n    gl_Position =  MVP * vec4(inPosition, 1.0);\n}\n\n"; }
const char *get_res_particles_render_vert_glsl () { return "#version 330\n\nlayout (location = 0) in vec3 vPosition;\nlayout (location = 2) in vec3 vColor;\nlayout (location = 3) in float fLifeTime;\nlayout (location = 4) in float fSize;\nlayout (location = 5) in float iType;\n\nuniform mat4 viewMatrix;\n\nout vec3 vColorPass;\nout float fLifeTimePass;\nout float fSizePass;\nout float iTypePass;\n\nvoid main()\n{\n   gl_Position = vec4(vPosition, 1.0);\n   vColorPass = vColor;\n   fSizePass = fSize;\n   fLifeTimePass = fLifeTime;\n   iTypePass = iType;\n}\n"; }
const char *get_res_particles_update_vert_glsl () { return "#version 330\n\nlayout (location = 0) in vec3 vPosition;\nlayout (location = 1) in vec3 vVelocity;\nlayout (location = 2) in vec3 vColor;\nlayout (location = 3) in float fLifeTime;\nlayout (location = 4) in float fSize;\nlayout (location = 5) in float iType;\nlayout (location = 6) in float reuse;\n\nout vec3 vPositionPass;\nout vec3 vVelocityPass;\nout vec3 vColorPass;\nout float fLifeTimePass;\nout float fSizePass;\nout float iTypePass;\nout float reusePass;\n\nvoid main()\n{\n    vPositionPass = vPosition;\n    vVelocityPass = vVelocity;\n    vColorPass = vColor;\n    fLifeTimePass = fLifeTime;\n    fSizePass = fSize;\n    iTypePass = iType;\n    reusePass = reuse;\n}\n"; }
const char *get_res_object_select_frag_glsl () { return "#version 330\n\nuniform vec4 objectID;\n\nout vec4 colour;\n\nvoid main()\n{\n    colour = objectID;\n}\n"; }
const char *get_res_particles_update_geom_glsl () { return "#version 330\n\nlayout(points) in;\nlayout(points) out;\nlayout(max_vertices = 30) out;\n\n// All that we get from vertex shader\n\nin vec3 vPositionPass[];\nin vec3 vVelocityPass[];\nin vec3 vColorPass[];\nin float fLifeTimePass[];\nin float fSizePass[];\nin float iTypePass[];\nin float reusePass[];\n\n// All that we send further\n\nout vec3 vPositionOut;\nout vec3 vVelocityOut;\nout vec3 vColorOut;\nout float fLifeTimeOut;\nout float fSizeOut;\nout float iTypeOut;\nout float reuseOut;\n\nuniform vec3 vGenPosition; // Position where new particles are spawned\nuniform vec3 vGenGravityVector; // Gravity vector for particles - updates velocity of particles \nuniform vec3 vGenVelocityMin; // Velocity of new particle - from min to (min+range)\nuniform vec3 vGenVelocityRange;\n\nuniform vec3 vGenColor;\nuniform float fGenSize; \nuniform float fDim;\nuniform float ttime;\n\nuniform float fGenLifeMin, fGenLifeRange; // Life of new particle - from min to (min+range)\nuniform float fTimePassed; // Time passed since last frame\n\nuniform vec3 vRandomSeed; // Seed number for our random number function\nvec3 vLocalSeed;\n\nuniform int iNumToGenerate; // How many particles will be generated next time, if greater than zero, particles are generated\nuniform sampler1D tsampler[1];\n//varying vec3 v_texCoord3D;\n\nhighp float rand(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nhighp float rand_pos(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return (fract(sin(sn) * c) + 1.0) / 2.f;\n}\n\nvec3 rand_v3(vec3 co, float axel)\n{\n    return vec3(rand(co.xy), rand(co.xz), rand(co.yz)) * axel;\n}\n\nvec3 rand_v3_pos(vec3 co, float axel)\n{\n    return vec3(rand_pos(co.xz), rand_pos(co.yz), rand_pos(co.xy)) * axel;\n}\n\nvec3 rand_v3_2(float TexCoord)\n{\n    vec3 r = texture(tsampler[0], TexCoord).xyz;\n    r = rand_v3(r, 1);\n    r -= vec3(0.5, 0.5, 0.5);\n    return r;\n}\n\nvec3 some_rand()\n{\n    vec3 val = vRandomSeed / ttime;\n    val.x = rand(val.xy);\n    val.y = rand(val.yz);\n    val.z = rand(val.xy);\n    val = rand_v3(val, 1.0);\n    return val;\n}\n\n#define PI 3.14159\n#define PI2 PI * 2.0\n#define INC PI / 8.0\n#define INC2 PI2 / 8.0\n#define P_LAUNCH 0.0f\n#define P_SHELL 1.0f\n#define P_SHELL2 2.0f\n\nvoid main()\n{\n     float Age = fLifeTimePass[0] + fTimePassed;\n\n     if(iTypePass[0] == P_LAUNCH)\n     {\n        if(Age > fGenLifeRange)\n        {\n            for (int i = 0 ; i < iNumToGenerate ; i++)\n            {\n                vPositionOut = vGenPosition + some_rand() * 20;\n                vec3 r = some_rand();\n//                r.y = max(r.y, 0.3);\n                vVelocityOut = normalize(r) + some_rand() * 3;\n                vColorOut = vGenColor;\n                fLifeTimeOut = 0.0;\n                fSizeOut = fGenSize;\n                iTypeOut = P_SHELL;\n                reuseOut = P_LAUNCH;\n                EmitVertex();\n                EndPrimitive();\n            }\n            Age = 0.0;\n        }\n        vPositionOut = vGenPosition;\n        vVelocityOut = vGenVelocityRange;\n        vColorOut = vGenColor;\n        fLifeTimeOut = Age;\n        fSizeOut = fGenSize;\n        iTypeOut = P_LAUNCH;\n        reuseOut = P_LAUNCH;\n        EmitVertex();\n        EndPrimitive();\n     }\n     else\n     {\n        float DeltaTimeSecs = fTimePassed / 1000.0f;\n        float t1 = fLifeTimePass[0] / 1000.0;\n        float t2 = Age / 1000.0;\n        vec3 DeltaP = DeltaTimeSecs * vVelocityPass[0];\n        vec3 DeltaV = some_rand() * DeltaTimeSecs;\n        if (iTypePass[0] == P_SHELL)\n        {\n            if (Age < fGenLifeMin)\n            {\n                iTypeOut = P_SHELL;\n                vPositionOut = vPositionPass[0] + DeltaP;\n                vVelocityOut = vVelocityPass[0] + DeltaV;\n                vColorOut = vColorPass[0];\n                fLifeTimeOut = Age;\n                fSizeOut = fSizePass[0];\n                reuseOut = reusePass[0];\n                EmitVertex();\n                EndPrimitive();\n            }\n            else\n            {\n                for (int i = 0 ; i < iNumToGenerate ; i++)\n                {\n                    iTypeOut = P_SHELL2;\n                    vPositionOut = vPositionPass[0] + some_rand();\n                    vec3 r = some_rand();\n                    vVelocityOut = normalize(r) * 2 + some_rand() * 5;\n                    fLifeTimeOut = 0.0f;\n                    fSizeOut = fSizePass[0];\n                    reuseOut = reusePass[0];\n                    vColorOut = vColorPass[0];\n                    EmitVertex();\n                    EndPrimitive();\n                }\n            }\n        }\n        else\n        {\n            if (Age < fGenLifeRange)\n            {\n                iTypeOut = P_SHELL2;\n                vPositionOut = vPositionPass[0] + DeltaP;\n                vVelocityOut = vVelocityPass[0] + DeltaV;\n                vColorOut = vColorPass[0];\n                fLifeTimeOut = Age;\n                fSizeOut = fSizePass[0];\n                reuseOut = reusePass[0];\n                EmitVertex();\n                EndPrimitive();\n            }\n        }\n     }\n}\n"; }
const char *get_res_object_vert_glsl () { return "#version 330\n\nlayout(location = 0) in vec3 inPosition;\nlayout(location = 1) in vec3 inNormal;\nlayout(location = 2) in vec2 inUV;\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 modelMatrix;\nuniform vec3 lightPosition;\n\nout vec2 UV;\nout vec3 Position_worldspace;\nout vec3 Normal_cameraspace;\nout vec3 EyeDirection_cameraspace;\nout vec3 LightDirection_cameraspace;\n\nvoid main()\n{\n    UV = inUV;\n\n    vec4 tmpPos = modelMatrix * viewMatrix * vec4(inPosition,1);\n    Position_worldspace = tmpPos.xyz;\n\n    vec4 other_pos = vec4(0.1, 0.1, 0.2, 1.0);\n\n    vec4 tmpPosCam = modelMatrix * viewMatrix * vec4(inPosition,1);\n    vec3 PosCam = tmpPosCam.xyz;\n\n    EyeDirection_cameraspace = vec3(tmpPosCam - tmpPos).xyz;\n\n    vec4 tmpLightPos = modelMatrix * viewMatrix * vec4(lightPosition ,1);\n    LightDirection_cameraspace = (tmpLightPos - tmpPosCam).xyz;\n\n    vec4 tmpNormal = modelMatrix * vec4(inNormal,0);\n    Normal_cameraspace = normalize(tmpNormal).xyz;\n\n    mat4 MVP = projectionMatrix * viewMatrix * modelMatrix;\n    gl_Position = MVP * vec4(inPosition, 1.0);\n}\n\n"; }
const char *get_res_object_select_vert_glsl () { return "#version 330\n\nlayout(location = 0) in vec3 inPosition;\nlayout(location = 1) in vec3 inNormal;\nlayout(location = 2) in vec2 inUV;\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 modelMatrix;\n\nvoid main()\n{\n    mat4 MVP = projectionMatrix * viewMatrix * modelMatrix;\n    gl_Position = MVP * vec4(inPosition, 1.0);\n}\n\n"; }
const char *get_res_skybox_vert_glsl () { return "#version 330\n\nlayout(location = 0) in vec3 inPosition;\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nsmooth out vec4 UV;\n\nvoid main()\n{\n    UV = inPosition;\n    vec4 VPp =  projectionMatrix * viewMatrix * vec4(inPosition, 1);\n    vec4 nVPp = normalize(VPp);\n    VPp.xyw\n    gl_Position = vec4(VPp.xy, nVPp.z, VPp.w);\n}\n"; }

